name: DevSecOps Agentic AI Pipeline (BugBuster)

on:
  push:
    branches: [feature/devsecops-agent-bgbstr]
  workflow_dispatch:

concurrency:
  group: devsecops-${{ github.ref }}
  cancel-in-progress: true

# ðŸ”§ Recommended for AutoFix + PR job
permissions:
  contents: write
  pull-requests: write

env:
  JAVA_VERSION: "17"
  PYTHON_VERSION: "3.12"
  APP_DIR: "java-pilot-app"
  REPORTS_DIR: "reports"
  MIN_SEVERITY: "high"
  LLM_ENABLED: "true"
  LLM_EXPLAIN: "0"
  LLM_MODE: "openai"
  BASE_BRANCH: "feature/devsecops-agent-bgbstr"

jobs:

  # ============================================================
  # ðŸ” VAULT CONNECTION VALIDATION
  # ============================================================
  Vault-Connection-Check:
    runs-on: ubuntu-latest
    steps:
      - name: Validate Vault Connectivity
        run: |
          echo "ðŸ” Testing connectivity to HashiCorp Vault..."
          VAULT_URL="${{ secrets.VAULT_ADDR }}/v1/sys/health"
          echo "Vault Health Endpoint: $VAULT_URL"

          HTTP_CODE=$(curl -s -o /tmp/vault_health.json -w "%{http_code}" \
            --connect-timeout 10 --max-time 15 "$VAULT_URL" || echo "000")

          echo "HTTP Status Code: $HTTP_CODE"
          cat /tmp/vault_health.json || true

          if [ "$HTTP_CODE" = "000" ]; then
            echo "âŒ FAILED: Cannot reach Vault server. Check EC2 Security Group (port 8200) and VAULT_ADDR secret."
            exit 1
          elif [ "$HTTP_CODE" = "200" ]; then
            echo "âœ… Vault is reachable, initialized, and unsealed."
          elif [ "$HTTP_CODE" = "429" ]; then
            echo "âš ï¸ Vault is reachable but in standby mode."
          elif [ "$HTTP_CODE" = "472" ]; then
            echo "âš ï¸ Vault is reachable but in recovery mode."
          elif [ "$HTTP_CODE" = "501" ]; then
            echo "âŒ FAILED: Vault is reachable but NOT initialized."
            exit 1
          elif [ "$HTTP_CODE" = "503" ]; then
            echo "âŒ FAILED: Vault is reachable but SEALED. Run 'vault operator unseal' on EC2."
            exit 1
          else
            echo "âš ï¸ Unexpected status code: $HTTP_CODE"
            exit 1
          fi

      - name: Validate Vault Secret Fetch (AppRole Auth)
        id: vault_check
        uses: hashicorp/vault-action@v3
        with:
          url: ${{ secrets.VAULT_ADDR }}
          method: approle
          roleId: ${{ secrets.VAULT_ROLE_ID }}
          secretId: ${{ secrets.VAULT_SECRET_ID }}
          secrets: |
            secret/data/openai api_key | OPENAI_API_KEY

      - name: Confirm Secret Retrieved
        run: |
          if [ -z "${{ steps.vault_check.outputs.OPENAI_API_KEY }}" ]; then
            echo "âŒ FAILED: OPENAI_API_KEY was NOT fetched from Vault."
            exit 1
          else
            MASKED_KEY=$(echo "${{ steps.vault_check.outputs.OPENAI_API_KEY }}" | cut -c1-7)
            echo "âœ… SUCCESS: OPENAI_API_KEY fetched from Vault (starts with: ${MASKED_KEY}...)"
            echo "ðŸ” Secret is available for downstream jobs."
          fi

  # ============================================================
  # BUILD APP
  # ============================================================
  Build-Java-App:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
  
      - uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: ${{ env.JAVA_VERSION }}
          cache: maven
  
      - run: mvn -B clean package -DskipTests -f $APP_DIR/pom.xml
  
      - name: Show target
        run: ls -la "$APP_DIR/target"
  
      - uses: actions/upload-artifact@v4
        with:
          name: app-target
          path: ${{ env.APP_DIR }}/target/

  # ============================================================
  # SAST
  # ============================================================
  SAST-Scanning:
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
  
      - uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: ${{ env.JAVA_VERSION }}
  
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
  
      - run: mkdir -p $REPORTS_DIR
  
      # Reuse compiled classes (no rebuild)
      - uses: actions/download-artifact@v4
        with:
          name: app-target
          path: ${{ env.APP_DIR }}/target/
  
      # Semgrep on source (no rebuild)
      - name: Semgrep (Java + OWASP Top 10)
        run: |
          pip install semgrep
          semgrep scan \
            --config=p/java \
            --config=p/owasp-top-ten \
            --json \
            --output "$REPORTS_DIR/semgrep.json" \
            "$APP_DIR/src/main/java" || echo '{}' > "$REPORTS_DIR/semgrep.json"
  
      # SpotBugs on compiled classes already present in target/
      - name: SpotBugs XML
        run: |
          # If you have a SpotBugs plugin configured in pom you can run mvn verify spotbugs:spotbugs
          # but that would recompile. Instead, call the CLI if available; otherwise keep Maven but skip 'clean'.
          # EASY path: run mvn but DON'T clean or recompile sources:
          mvn -q -DskipTests -f $APP_DIR/pom.xml spotbugs:spotbugs || true
          if [ -f "$APP_DIR/target/spotbugsXml.xml" ]; then
            cp "$APP_DIR/target/spotbugsXml.xml" reports/spotbugs.xml
          else
            echo "<BugCollection/>" > reports/spotbugs.xml
          fi

      - name: Convert SpotBugs XML â†’ JSON
        run: |
          pip install xmltodict
          python - << 'PY'
          import xmltodict, json, pathlib
          p = pathlib.Path("reports/spotbugs.xml")
          out = pathlib.Path("reports/spotbugs.json")
          if p.exists() and p.stat().st_size>0:
              data = xmltodict.parse(p.read_text())
              out.write_text(json.dumps(data, indent=2))
          else:
              out.write_text("{}")
          PY

      - name: SAST Stage Summary
        uses: ./.github/actions/stage-summary
        with:
          stage: SAST
          reports_dir: reports
          files: semgrep.json,spotbugs.json    

      - uses: actions/upload-artifact@v4
        with:
          name: sast-reports
          path: reports/*.json
          if-no-files-found: ignore

  # ============================================================
  # SECRETS
  # ============================================================
  # Secrets-Scanning:
  #   runs-on: ubuntu-latest
  #   continue-on-error: true
  #   steps:
  #     - uses: actions/checkout@v4
  #     - run: mkdir -p $REPORTS_DIR
  #     - run: sudo apt-get update && sudo apt-get install -y jq
  #     - name: Install gitleaks
  #       run: |
  #         VERSION=$(curl -s https://api.github.com/repos/gitleaks/gitleaks/releases/latest | jq -r .tag_name)
  #         curl -L -o gitleaks.tar.gz "https://github.com/gitleaks/gitleaks/releases/download/${VERSION}/gitleaks_${VERSION#v}_linux_x64.tar.gz"
  #         tar -xzf gitleaks.tar.gz && sudo mv gitleaks /usr/local/bin/
  #     - name: Run gitleaks
  #       run: |
  #         gitleaks detect --source "$APP_DIR" --report-format json \
  #           --report-path "$REPORTS_DIR/gitleaks.json" || echo '{}' > "$REPORTS_DIR/gitleaks.json"
      
  #     - name: Secrets Stage Summary
  #       uses: ./.github/actions/stage-summary
  #       with:
  #         stage: Secrets
  #         reports_dir: reports
  #         files: gitleaks.json
      
  #     - uses: actions/upload-artifact@v4
  #       with:
  #         name: secrets-reports
  #         path: reports/*.json
  #         if-no-files-found: ignore

  # # =========================================================
  # # SCA (Trivy FS)
  # # =========================================================
  # SCA-Scanning:
  #   runs-on: ubuntu-latest
  #   continue-on-error: true
  #   env:
  #     TRIVY_VERSION: "0.51.2"   # pin to avoid CI drift
  #   steps:
  #     - uses: actions/checkout@v4

  #     - name: Prepare reports folder
  #       run: mkdir -p "$REPORTS_DIR"

  #     - name: Install Trivy (pinned)
  #       run: |
  #         curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b ./bin "v${TRIVY_VERSION}"
  #         ./bin/trivy --version

  #     - name: Trivy FS (SCA) scan
  #       run: |
  #         set -e
  #         : > "$REPORTS_DIR/trivy_fs.json"
  #         ./bin/trivy fs \
  #           --format json \
  #           --output "$REPORTS_DIR/trivy_fs.json" \
  #           --timeout 10m \
  #           "$APP_DIR" || true
  #         if [ ! -s "$REPORTS_DIR/trivy_fs.json" ]; then
  #           echo '{}' > "$REPORTS_DIR/trivy_fs.json"
  #         fi

  #     - name: SCA Stage Summary
  #       uses: ./.github/actions/stage-summary
  #       with:
  #         stage: SCA
  #         reports_dir: reports
  #         files: trivy_fs.json

  #     - uses: actions/upload-artifact@v4
  #       with:
  #         name: sca-reports
  #         path: reports/*.json
  #         if-no-files-found: ignore

  # # =========================================================
  # # IAC (tfsec and k8s)
  # # =========================================================
  # IAC-Scanning:
  #   runs-on: ubuntu-latest
  #   continue-on-error: true
  #   steps:
  #     - uses: actions/checkout@v4
  
  #     - name: Prepare reports folder
  #       run: mkdir -p "$REPORTS_DIR"
  
  #     - name: Install Checkov
  #       run: pip install checkov
  
  #     - name: Checkov (Terraform JSON)
  #       run: |
  #         : > "$REPORTS_DIR/checkov_tf.json"
  #         if [ -d "$APP_DIR/terraform" ]; then
  #           checkov -d "$APP_DIR/terraform" --framework terraform -o json > "$REPORTS_DIR/checkov_tf.json" || true
  #         else
  #           echo '{}' > "$REPORTS_DIR/checkov_tf.json"
  #         fi
  #         if [ ! -s "$REPORTS_DIR/checkov_tf.json" ]; then echo '{}' > "$REPORTS_DIR/checkov_tf.json"; fi
  
  #     - name: Checkov (Kubernetes JSON)
  #       run: |
  #         : > "$REPORTS_DIR/checkov_k8s.json"
  #         if [ -d "$APP_DIR/k8s" ]; then
  #           checkov -d "$APP_DIR/k8s" --framework kubernetes -o json > "$REPORTS_DIR/checkov_k8s.json" || true
  #         else
  #           echo '{}' > "$REPORTS_DIR/checkov_k8s.json"
  #         fi
  #         if [ ! -s "$REPORTS_DIR/checkov_k8s.json" ]; then echo '{}' > "$REPORTS_DIR/checkov_k8s.json"; fi
  
  #     - name: IaC Stage Summary
  #       uses: ./.github/actions/stage-summary
  #       with:
  #         stage: IaC
  #         reports_dir: reports
  #         files: checkov_tf.json,checkov_k8s.json

  #     - uses: actions/upload-artifact@v4
  #       with:
  #         name: iac-reports
  #         path: reports/*.json
  #         if-no-files-found: ignore

  # # ============================================================
  # # CONTAINER (Trivy Image)
  # # ============================================================
  # Container-Scanning:
  #   runs-on: ubuntu-latest
  #   needs: Build-Java-App
  #   continue-on-error: true
  #   env:
  #     TRIVY_VERSION: "0.51.2"
  #   steps:
  #     - uses: actions/checkout@v4
  
  #     # Download the jar produced by Build-Java-App
  #     - uses: actions/download-artifact@v4
  #       with:
  #         name: app-jar
  #         path: ${{ env.APP_DIR }}/target
  
  #     - name: Verify jar
  #       run: |
  #         echo "Listing target folder:"
  #         ls -la "$APP_DIR/target"
  #         if [ ! -f "$APP_DIR/target/java-pilot-app-1.0.0.jar" ]; then
  #           echo "âŒ JAR missing"
  #           exit 1
  #         fi
  
  #     - name: Prepare reports folder
  #       run: mkdir -p "$REPORTS_DIR"
  
  #     - name: Build Docker image (build from app folder)
  #       id: buildimg
  #       run: |
  #         if docker build -t java-pilot-app:1.0.0 "$APP_DIR" ; then
  #           echo "built=true" >> $GITHUB_OUTPUT
  #         else
  #           echo "built=false" >> $GITHUB_OUTPUT
  #         fi
  
  #     - name: Install Trivy (pinned)
  #       run: |
  #         curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b ./bin "v${TRIVY_VERSION}"
  #         ./bin/trivy --version
  
  #     - name: Trivy Image Scan (only if image built)
  #       if: steps.buildimg.outputs.built == 'true'
  #       run: |
  #         : > "$REPORTS_DIR/trivy_image.json"
  #         ./bin/trivy image \
  #           --format json \
  #           --timeout 10m \
  #           --output "$REPORTS_DIR/trivy_image.json" \
  #           java-pilot-app:1.0.0 || true
  #         if [ ! -s "$REPORTS_DIR/trivy_image.json" ]; then
  #           echo '{}' > "$REPORTS_DIR/trivy_image.json"
  #         fi
  
  #     - name: Trivy Image Scan (fallback when build failed)
  #       if: steps.buildimg.outputs.built != 'true'
  #       run: |
  #         echo '{}' > "$REPORTS_DIR/trivy_image.json"
  
  #     - name: Container Stage Summary
  #       uses: ./.github/actions/stage-summary
  #       with:
  #         stage: Container
  #         reports_dir: reports
  #         files: trivy_image.json

  #     - uses: actions/upload-artifact@v4
  #       with:
  #         name: container-reports
  #         path: reports/*.json
  #         if-no-files-found: ignore

  # # ============================================================
  # # DAST
  # # ============================================================
  # DAST-Scanning:
  #   runs-on: ubuntu-latest
  #   needs: Build-Java-App
  #   continue-on-error: true
  #   steps:
  #     - uses: actions/checkout@v4
  
  #     - uses: actions/download-artifact@v4
  #       with:
  #         name: app-jar
  #         path: ${{ env.APP_DIR }}/target
  
  #     - run: mkdir -p $REPORTS_DIR
  
  #     - name: Start Application
  #       run: |
  #         mkdir -p config/dummy
  #         java -jar "$APP_DIR/target/java-pilot-app-1.0.0.jar" \
  #           --spring.config.import=optional:file:./config/*/ &
  #         sleep 40
  
  #     - name: OWASP ZAP Baseline
  #       run: |
  #         mkdir -p zap-output
  #         docker run --rm \
  #           -u root \
  #           --network=host \
  #           -v "$(pwd)/zap-output":/zap/wrk:rw \
  #           ghcr.io/zaproxy/zaproxy:stable \
  #           zap-baseline.py \
  #           -t http://localhost:8080 \
  #           -J zap.json || true
  #         if [ -f zap-output/zap.json ]; then
  #           mv zap-output/zap.json "$REPORTS_DIR/zap.json"
  #         else
  #           echo '{}' > "$REPORTS_DIR/zap.json"
  #         fi
  
  #     - name: DAST Stage Summary
  #       uses: ./.github/actions/stage-summary
  #       with:
  #         stage: DAST
  #         reports_dir: reports
  #         files: zap.json

  #     - uses: actions/upload-artifact@v4
  #       with:
  #         name: dast-reports
  #         path: reports/*.json
  #         if-no-files-found: ignore

  # # ============================================================
  # # AGGREGATE
  # # ============================================================
  # Aggregate-Scanning-Reports:
  #   runs-on: ubuntu-latest
  #   needs: [SAST-Scanning, Secrets-Scanning, SCA-Scanning, IAC-Scanning, Container-Scanning, DAST-Scanning]
  #   # needs: [SAST-Scanning, IAC-Scanning]
    
  #   if: always()
  #   steps:
  #     - uses: actions/download-artifact@v4
  #       with:
  #         path: collected-reports

  #     - name: Collate JSON
  #       run: |
  #         mkdir -p final-reports
  #         find collected-reports -name "*.json" -exec cp {} final-reports/ \; || true
  #         echo "DEBUG: Aggregated files"
  #         ls -la final-reports || true

  #     - uses: actions/upload-artifact@v4
  #       with:
  #         name: all-scan-reports
  #         path: final-reports/*.json

  # ============================================================
  # AI GATE
  # ============================================================
  # AI-Gate-Analysis:
  #   runs-on: ubuntu-latest
  #   needs: Aggregate-Scanning-Reports
  #   steps:
  #     - uses: actions/checkout@v4

  #     - uses: actions/setup-python@v5
  #       with:
  #         python-version: ${{ env.PYTHON_VERSION }}

  #     - run: pip install -r requirements.txt

  #     - uses: actions/download-artifact@v4
  #       with:
  #         name: all-scan-reports
  #         path: reports

  #     - run: mkdir -p agent_output

  #     - run: |
  #         python main.py --reports-dir reports --output-dir agent_output --mode=gate --skip-llm

  #     - name: Debug Gate Output
  #       run: |
  #         echo "DEBUG decision.json"
  #         cat agent_output/decision.json || true
  #         echo "DEBUG files"
  #         ls -la agent_output || true

  #     - uses: actions/upload-artifact@v4
  #       with:
  #         name: ai-results
  #         path: agent_output/

  # # ============================================================
  # # SECURITY GATE
  # # ============================================================
  # Security-Gate:
  #   runs-on: ubuntu-latest
  #   needs: AI-Gate-Analysis
  #   outputs:
  #     gate_failed: ${{ steps.read.outputs.gate_failed }}
  #   steps:
  #     - uses: actions/download-artifact@v4
  #       with:
  #         name: ai-results
  #         path: agent_output

  #     - run: sudo apt-get update && sudo apt-get install -y jq

  #     - id: read
  #       run: |
  #         STATUS=$(jq -r '.decision' agent_output/decision.json)
  #         echo "DEBUG Gate decision = $STATUS"
  #         if [ "$STATUS" = "FAIL" ]; then
  #           echo "gate_failed=true" >> $GITHUB_OUTPUT
  #         else
  #           echo "gate_failed=false" >> $GITHUB_OUTPUT
  #         fi

  # # ============================================================
  # # TRIAGE
  # # ============================================================
  # LLM-Triage:
  #   runs-on: ubuntu-latest
  #   needs: [Security-Gate, Vault-Connection-Check]
  #   steps:
  #     - uses: actions/checkout@v4

  #     - uses: actions/setup-python@v5
  #       with:
  #         python-version: ${{ env.PYTHON_VERSION }}

  #     - run: pip install -r requirements.txt

  #     - uses: actions/download-artifact@v4
  #       with:
  #         name: all-scan-reports
  #         path: reports

  #     - uses: actions/download-artifact@v4
  #       with:
  #         name: ai-results
  #         path: agent_output

  #     # ðŸ” Fetch OpenAI API Key from HashiCorp Vault
  #     - name: Import Secrets from HashiCorp Vault
  #       id: vault
  #       uses: hashicorp/vault-action@v3
  #       with:
  #         url: ${{ secrets.VAULT_ADDR }}
  #         method: approle
  #         roleId: ${{ secrets.VAULT_ROLE_ID }}
  #         secretId: ${{ secrets.VAULT_SECRET_ID }}
  #         secrets: |
  #           secret/data/openai api_key | OPENAI_API_KEY

  #     - name: Run Triage
  #       run: |
  #         python main.py --reports-dir reports --output-dir agent_output --mode=triage
  #       env:
  #         OPENAI_API_KEY: ${{ steps.vault.outputs.OPENAI_API_KEY }}

  #     - name: Debug triage
  #       run: |
  #         echo "DEBUG triage output"
  #         ls -la agent_output
  #         cat agent_output/* || true

  #     - uses: actions/upload-artifact@v4
  #       with:
  #         name: triage-output
  #         path: agent_output/

  # # ============================================================
  # # SUGGESTIONS
  # # ============================================================
  # LLM-Suggestions:
  #   runs-on: ubuntu-latest
  #   needs: LLM-Triage
  #   steps:
  #     - uses: actions/checkout@v4

  #     - uses: actions/setup-python@v5
  #       with:
  #         python-version: ${{ env.PYTHON_VERSION }}

  #     - run: pip install -r requirements.txt

  #     - uses: actions/download-artifact@v4
  #       with:
  #         name: triage-output
  #         path: agent_output

  #     - uses: actions/download-artifact@v4
  #       with:
  #         name: all-scan-reports
  #         path: reports

  #     # ðŸ” Fetch OpenAI API Key from HashiCorp Vault
  #     - name: Import Secrets from HashiCorp Vault
  #       id: vault
  #       uses: hashicorp/vault-action@v3
  #       with:
  #         url: ${{ secrets.VAULT_ADDR }}
  #         method: approle
  #         roleId: ${{ secrets.VAULT_ROLE_ID }}
  #         secretId: ${{ secrets.VAULT_SECRET_ID }}
  #         secrets: |
  #           secret/data/openai api_key | OPENAI_API_KEY

  #     - name: Run Suggestions
  #       run: |
  #         python main.py --reports-dir reports --output-dir agent_output --mode=advise
  #       env:
  #         OPENAI_API_KEY: ${{ steps.vault.outputs.OPENAI_API_KEY }}

  #     - name: Debug suggestions
  #       run: |
  #         echo "DEBUG suggestions"
  #         ls -la agent_output
  #         cat agent_output/* || true

  #     - uses: actions/upload-artifact@v4
  #       with:
  #         name: suggestions-output
  #         path: agent_output/

  # # ============================================================
  # # AUTOFIX
  # # ============================================================
  # AutoFix-PR:
  #   runs-on: ubuntu-latest
  #   needs: [LLM-Suggestions, Security-Gate]
  #   if: needs.Security-Gate.outputs.gate_failed == 'true'
  #   env:
  #     GH_TOKEN: ${{ github.token }}          # required by gh
  #     # BASE_BRANCH inherited from top-level env (e.g., hackathon-feature-s)
  
  #   steps:
  #     - uses: actions/checkout@v4
  #       with:
  #         fetch-depth: 0
  
  #     - uses: actions/setup-python@v5
  #       with:
  #         python-version: ${{ env.PYTHON_VERSION }}
  
  #     - run: pip install -r requirements.txt
  
  #     - uses: actions/download-artifact@v4
  #       with:
  #         name: suggestions-output
  #         path: agent_output
  
  #     - uses: actions/download-artifact@v4
  #       with:
  #         name: all-scan-reports
  #         path: reports
  
  #     - name: Setup Git identity
  #       run: |
  #         git config user.name "github-actions"
  #         git config user.email "github-actions@github.com"
  
  #     - name: Install GitHub CLI
  #       run: |
  #         sudo apt-get update
  #         sudo apt-get install -y gh
  
  #     - name: Import Secrets from HashiCorp Vault
  #       id: vault
  #       uses: hashicorp/vault-action@v3
  #       with:
  #         url: ${{ secrets.VAULT_ADDR }}
  #         method: approle
  #         roleId: ${{ secrets.VAULT_ROLE_ID }}
  #         secretId: ${{ secrets.VAULT_SECRET_ID }}
  #         secrets: |
  #           secret/data/openai api_key | OPENAI_API_KEY
  
  #     # ---- Terraform fmt BEFORE autofix â†’ fmt changes included in AI branch ----
  #     - name: Setup Terraform
  #       uses: hashicorp/setup-terraform@v3
  #       with:
  #         terraform_wrapper: false
  
  #     - name: Terraform fmt (pre-fix, keep diffs tidy)
  #       run: |
  #         if [ -d "hackathon-vuln-app/terraform" ]; then
  #           terraform -version || true
  #           terraform fmt -recursive hackathon-vuln-app/terraform || true
  #         fi
  
  #     # AI autofix (LLM + deterministic Terraform/K8s hardeners); AST off
  #     - name: Run autofix
  #       run: |
  #         python main.py --reports-dir reports --output-dir agent_output --mode=fix
  #       env:
  #         OPENAI_API_KEY: ${{ steps.vault.outputs.OPENAI_API_KEY }}
  #         MIN_SEVERITY: ${{ env.MIN_SEVERITY }}
  #         AST_ENABLED: "false"
  
  #     # Optional: post-fix Checkov JSON signals (no commits here)
  #     - name: Install Checkov
  #       run: pip install checkov
  
  #     - name: Checkov (Terraform JSON, post-fix)
  #       run: |
  #         mkdir -p reports
  #         if [ -d "hackathon-vuln-app/terraform" ]; then
  #           checkov -d hackathon-vuln-app/terraform --framework terraform -o json > reports/checkov_tf_postfix.json || echo '{}' > reports/checkov_tf_postfix.json
  #         else
  #           echo '{}' > reports/checkov_tf_postfix.json
  #         fi
  
  #     - name: Checkov (Kubernetes JSON, post-fix)
  #       run: |
  #         mkdir -p reports
  #         if [ -d "hackathon-vuln-app/kubernetes" ]; then
  #           checkov -d hackathon-vuln-app/kubernetes --framework kubernetes -o json > reports/checkov_k8s_postfix.json || echo '{}' > reports/checkov_k8s_postfix.json
  #         else
  #           echo '{}' > reports/checkov_k8s_postfix.json
  #         fi
  
  #     - name: Debug patch manifest
  #       run: |
  #         echo "Patch manifest"
  #         cat agent_output/patch_manifest.json || true
  
  #     # (optional) show target base on runner (helps when BASE_BRANCH changes)
  #     - name: Debug base branch
  #       run: |
  #         echo "BASE_BRANCH=${BASE_BRANCH}"
  #         git ls-remote --heads origin "${BASE_BRANCH}" | cat
  
  #     # (optional) Print the AI PR link if GitPRAgent captured it
  #     - name: Show PR link (if any)
  #       run: |
  #         if [ -f agent_output/pr_comment.md ]; then
  #           echo "PR URL:"
  #           cat agent_output/pr_comment.md
  #         else
  #           echo "No PR link recorded; the AI may have fallen back to branch-only."
  #         fi
  
  #     - name: Debug final
  #       run: |
  #         git status
  #         git branch -a
  #         ls -la agent_output
  
  #     - uses: actions/upload-artifact@v4
  #       with:
  #         name: autofix-output
  #         path: |
  #           agent_output/
  #           reports/checkov*_postfix.json
  #         if-no-files-found: ignore

# AutoFix-PR:
#   runs-on: ubuntu-latest
#   needs: [LLM-Suggestions, Security-Gate]
#   if: needs.Security-Gate.outputs.gate_failed == 'true'
#   env:
#     GH_TOKEN: ${{ github.token }}          # required by gh
#     # BASE_BRANCH inherited from the top-level env (hackathon-feature-s)

#   steps:
#     - uses: actions/checkout@v4
#       with:
#         fetch-depth: 0

#     - uses: actions/setup-python@v5
#       with:
#         python-version: ${{ env.PYTHON_VERSION }}

#     - run: pip install -r requirements.txt

#     - uses: actions/download-artifact@v4
#       with:
#         name: suggestions-output
#         path: agent_output

#     - uses: actions/download-artifact@v4
#       with:
#         name: all-scan-reports
#         path: reports

#     - name: Setup Git identity
#       run: |
#         git config user.name "github-actions"
#         git config user.email "github-actions@github.com"

#     - name: Install GitHub CLI
#       run: |
#         sudo apt-get update
#         sudo apt-get install -y gh

#     - name: Import Secrets from HashiCorp Vault
#       id: vault
#       uses: hashicorp/vault-action@v3
#       with:
#         url: ${{ secrets.VAULT_ADDR }}
#         method: approle
#         roleId: ${{ secrets.VAULT_ROLE_ID }}
#         secretId: ${{ secrets.VAULT_SECRET_ID }}
#         secrets: |
#           secret/data/openai api_key | OPENAI_API_KEY

#     - name: Run autofix
#       run: |
#         python main.py --reports-dir reports --output-dir agent_output --mode=fix
#       env:
#         OPENAI_API_KEY: ${{ steps.vault.outputs.OPENAI_API_KEY }}
#         MIN_SEVERITY: ${{ env.MIN_SEVERITY }}
#         AST_ENABLED: "false"

#     - name: Setup Terraform
#       uses: hashicorp/setup-terraform@v3
#       with:
#         terraform_wrapper: false

#     - name: Terraform fmt (keep diffs tidy)
#       run: |
#         if [ -d "hackathon-vuln-app/terraform" ]; then
#           terraform -version || true
#           terraform fmt -recursive hackathon-vuln-app/terraform || true
#         fi

#     - name: Install Checkov
#       run: pip install checkov

#     - name: Checkov (Terraform JSON, post-fix)
#       run: |
#         mkdir -p reports
#         if [ -d "hackathon-vuln-app/terraform" ]; then
#           checkov -d hackathon-vuln-app/terraform --framework terraform -o json > reports/checkov_tf_postfix.json || echo '{}' > reports/checkov_tf_postfix.json
#         else
#           echo '{}' > reports/checkov_tf_postfix.json
#         fi

#     - name: Checkov (Kubernetes JSON, post-fix)
#       run: |
#         mkdir -p reports
#         if [ -d "hackathon-vuln-app/kubernetes" ]; then
#           checkov -d hackathon-vuln-app/kubernetes --framework kubernetes -o json > reports/checkov_k8s_postfix.json || echo '{}' > reports/checkov_k8s_postfix.json
#         else
#           echo '{}' > reports/checkov_k8s_postfix.json
#         fi

#     - name: Debug patch manifest
#       run: |
#         echo "Patch manifest"
#         cat agent_output/patch_manifest.json || true

#     - name: Debug repo status before branch
#       run: |
#         git status
#         git diff --name-only || true

#     # (optional) make sure we see the intended base branch on runner
#     - name: Debug base branch
#       run: |
#         echo "BASE_BRANCH=${BASE_BRANCH}"
#         git ls-remote --heads origin "${BASE_BRANCH}" | cat

#     - name: Create unique branch & push
#       id: branchpush
#       run: |
#         set -e
#         UPSTREAM="${BASE_BRANCH}"
#         git fetch origin "$UPSTREAM"

#         if git diff --quiet "origin/$UPSTREAM"...HEAD && git diff --quiet; then
#           echo "No changes vs base â†’ skipping branch and PR."
#           echo "no_changes=true" >> $GITHUB_OUTPUT
#           echo "new_branch=" >> $GITHUB_OUTPUT
#           exit 0
#         fi

#         BR="autofix-$(date +%Y%m%d%H%M%S)-${RANDOM}"
#         echo "new_branch=$BR" >> $GITHUB_OUTPUT

#         git checkout -b "$BR"
#         git add -A
#         if git diff --cached --quiet; then
#           git push --set-upstream origin "$BR"
#         else
#           git commit -m "Autofix: security scan fixes"
#           git push --set-upstream origin "$BR"
#         fi

#     - name: Open PR
#       if: ${{ steps.branchpush.outputs.no_changes != 'true' }}
#       run: |
#         set -e
#         BR="${{ steps.branchpush.outputs.new_branch }}"
#         if [ -z "$BR" ]; then
#           echo "No new branch name â†’ no PR."
#           exit 0
#         fi

#         gh pr create \
#           --title "Autofix: security scan fixes" \
#           --body "Automated patches generated by the security agent." \
#           --base "$BASE_BRANCH" \
#           --head "$BR"

#     - name: Debug final
#       run: |
#         git status
#         git branch -a
#         ls -la agent_output

#     - uses: actions/upload-artifact@v4
#       with:
#         name: autofix-output
#         path: |
#           agent_output/
#           reports/checkov*_postfix.json
#         if-no-files-found: ignore

  # AutoFix-PR:
  #   runs-on: ubuntu-latest
  #   needs: [LLM-Suggestions, Security-Gate]
  #   if: needs.Security-Gate.outputs.gate_failed == 'true'
  #   steps:
  #     - uses: actions/checkout@v4
  #       with:
  #         fetch-depth: 0

  #     - uses: actions/setup-python@v5
  #       with:
  #         python-version: ${{ env.PYTHON_VERSION }}

  #     - run: pip install -r requirements.txt

  #     - uses: actions/download-artifact@v4
  #       with:
  #         name: suggestions-output
  #         path: agent_output

  #     - uses: actions/download-artifact@v4
  #       with:
  #         name: all-scan-reports
  #         path: reports

  #     - name: Debug workspace & POMs
  #       run: |
  #         echo "PWD=$(pwd)"
  #         find . -maxdepth 3 -type f -name pom.xml | sed 's|^\./||'

  #     # â­ REQUIRED (identity per job)
  #     - name: Setup Git identity
  #       run: |
  #         git config user.name "github-actions"
  #         git config user.email "github-actions@github.com"

  #     # â­ REQUIRED (gh CLI)
  #     - name: Install GitHub CLI
  #       run: |
  #         sudo apt-get update
  #         sudo apt-get install -y gh

  #     # # âœ… Setup Java (for AST fixer tool)
  #     # - name: Setup Java for AST fixer
  #     #   uses: actions/setup-java@v4
  #     #   with:
  #     #     distribution: temurin
  #     #     java-version: ${{ env.JAVA_VERSION }}
  #     #     cache: maven

  #     # # âœ… Pre-build AST fixer module
  #     # - name: Build AST fixer module
  #     #   run: |
  #     #     set -e
  #     #     test -f tools/java-ast-fixer/pom.xml || { echo "POM not found at tools/java-ast-fixer/pom.xml"; exit 1; }
  #     #     mvn -B -q -DskipTests package -f tools/java-ast-fixer/pom.xml
  #     #     mvn -v

  #     # ðŸ” Fetch OpenAI API key from Vault for LLM-enabled fixes
  #     - name: Import Secrets from HashiCorp Vault
  #       id: vault
  #       uses: hashicorp/vault-action@v3
  #       with:
  #         url: ${{ secrets.VAULT_ADDR }}
  #         method: approle
  #         roleId: ${{ secrets.VAULT_ROLE_ID }}
  #         secretId: ${{ secrets.VAULT_SECRET_ID }}
  #         secrets: |
  #           secret/data/openai api_key | OPENAI_API_KEY

  #     # ðŸš€ Run autofix (LLM enabled); hint engine where the AST POM is
  #     - name: Run autofix
  #       run: |
  #         python main.py --reports-dir reports --output-dir agent_output --mode=fix
  #       env:
  #         OPENAI_API_KEY: ${{ steps.vault.outputs.OPENAI_API_KEY }}
  #         MIN_SEVERITY: ${{ env.MIN_SEVERITY }}
  #         AST_FIXER_POM: tools/java-ast-fixer/pom.xml

  #     # ðŸ’… Optional: Neaten Terraform changes & quick post-fix signal
  #     - name: Terraform fmt (keep diffs tidy)
  #       run: |
  #         if [ -d "hackathon-vuln-app/terraform" ]; then
  #           cd hackathon-vuln-app/terraform
  #           terraform fmt -recursive || true
  #         fi

  #     - name: tfsec (post-fix quick check)
  #       run: |
  #         if [ -d "hackathon-vuln-app/terraform" ]; then
  #           curl -L https://github.com/aquasecurity/tfsec/releases/latest/download/tfsec-linux-amd64 -o tfsec
  #           chmod +x tfsec && sudo mv tfsec /usr/local/bin/
  #           tfsec --version || true
  #           tfsec . || true
  #         fi
  #       working-directory: hackathon-vuln-app/terraform

  #     # â­ Debug patch manifest
  #     - name: Debug patch manifest
  #       run: |
  #         echo "Patch manifest"
  #         cat agent_output/patch_manifest.json || true

  #     - name: Debug git diff before commit
  #       run: |
  #         git status
  #         git diff
  #         git diff --name-only || true

  #     # âœ… Commit & push changes if present (fallback even if GitPRAgent is absent)
  #     - name: Commit & push changes (if any)
  #       run: |
  #         if ! git diff --quiet || ! git diff --cached --quiet; then
  #           BR="autofix-$(date +%Y%m%d%H%M%S)"
  #           git checkout -b "$BR"
  #           git add -A
  #           if git diff --cached --quiet; then
  #             echo "No staged changes after add; skipping commit."
  #           else
  #             git commit -m "Autofix: security scan fixes"
  #             git push --set-upstream origin "$BR"
  #             echo "branch_name=$BR" >> $GITHUB_OUTPUT
  #           fi
  #         else
  #           echo "No changes to commit."
  #         fi

  #     # âœ… Open PR using gh
  #     - name: Open PR
  #       env:
  #         GH_TOKEN: ${{ github.token }}
  #       run: |
  #         BR=$(git rev-parse --abbrev-ref HEAD)
  #         if [[ "$BR" == autofix-* ]]; then
  #           gh pr create \
  #             --title "Autofix: security scan fixes" \
  #             --body "Automated patches generated by the security agent." \
  #             --base "$BASE_BRANCH" \
  #             --head "$BR"
  #         else
  #           echo "No new branch â†’ no PR."
  #         fi

  #     - name: Debug autofix
  #       run: |
  #         git status
  #         git branch -a
  #         ls -la agent_output

  #     - uses: actions/upload-artifact@v4
  #       with:
  #         name: autofix-output
  #         path: agent_output/

  #     # ðŸ“Š kube-score (install + run) â€” non-gating signal for K8s manifests
  #     - name: Install kube-score (latest)
  #       run: |
  #         set -e
  #         sudo apt-get update -y && sudo apt-get install -y jq
  #         # Resolve latest release tag (fallback to 1.20.0 if API fails)
  #         VER="$(curl -s https://api.github.com/repos/zegl/kube-score/releases/latest | jq -r '.tag_name' | sed 's/^v//' || true)"
  #         if [ -z "$VER" ] || [ "$VER" = "null" ]; then VER="1.20.0"; fi
  #         echo "Installing kube-score version: $VER"
  #         curl -L -o kube-score "https://github.com/zegl/kube-score/releases/download/v${VER}/kube-score_${VER}_linux_amd64"
  #         chmod +x kube-score && sudo mv kube-score /usr/local/bin/
  #         kube-score version
  
  #     - name: kube-score (JSON report)
  #       run: |
  #         if [ -d "hackathon-vuln-app/kubernetes" ]; then
  #           mkdir -p reports
  #           kube-score score \
  #             --output-format json \
  #             hackathon-vuln-app/kubernetes > reports/kube-score.json || true
  #         else
  #           echo "No Kubernetes folder found; writing empty JSON."
  #           mkdir -p reports
  #           echo '{"version":"2.1.0","runs":[]}' > reports/kube-score.json
  #         fi
  
  #     - uses: actions/upload-artifact@v4
  #       with:
  #         name: kube-score-reports
  #         path: reports/kube-score.json
  #         if-no-files-found: ignore     